{"ast":null,"code":"var _jsxFileName = \"/home/alexkimory/react-test/src/components/section/charts/TimeSerie.js\";\nimport React from \"react\";\nimport { Chart } from \"chart.js\";\nimport generateCurrentTime from \"../../../utils/generateCurrentTime\";\nimport generateRandomNumber from \"../../../utils/generateRandomNumber\";\nconst TIME_REPEAT = 2;\n\nclass TimeSerie extends React.Component {\n  constructor(...args) {\n    super(...args);\n    this.chartRef = React.createRef();\n    this.state = {\n      data: [],\n      labels: []\n    };\n\n    this.limitSizeOfStateData = size => {\n      if (this.state.data.lengh > size) {\n        console.log('in limted size data', this.state.data.lengh);\n        let reducedSize = this.state.data.lengh - size;\n        let data = this.state.data.slice(reducedSize);\n        console.log('after cut limted size data', data);\n        this.setState({\n          data: data\n        });\n      }\n\n      if (this.state.labels.lengh > size) {\n        let reducedSize = this.state.labels.lengh - size;\n        let labels = this.state.labels.slice(reducedSize);\n        this.setState({\n          labels: labels\n        });\n      }\n    };\n\n    this.updateTimeSerieEveryXSeconds = second => {\n      setInterval(() => {\n        console.log('this.s.data', this.state.data);\n        this.limitSizeOfStateData(3);\n        console.log('this.s.data', this.state.data); //update y axis with abitrary number of customer\n\n        this.setState({\n          data: [...this.state.data, generateRandomNumber()]\n        }); //update x axis with current time hour:minute:second\n\n        this.setState({\n          labels: [...this.state.labels, generateCurrentTime()]\n        }); //create chart and update it every X seconds\n\n        const myChartRef = this.chartRef.current.getContext(\"2d\");\n        new Chart(myChartRef, {\n          type: \"line\",\n          data: {\n            labels: this.state.labels,\n            datasets: [{\n              borderColor: \"red\",\n              showLine: true,\n              fill: false,\n              label: \"Customer in store\",\n              data: this.state.data\n            }]\n          },\n          options: {\n            scales: {\n              yAxes: [{\n                stacked: true,\n                ticks: {\n                  suggestedMin: 0,\n                  suggestedMax: 100,\n                  maxTicksLimit: 5,\n                  beginAtZero: true,\n                  stepSize: 0.5\n                }\n              }],\n              xAxes: []\n            }\n          }\n        });\n      }, second * 1000);\n    };\n  }\n\n  componentDidMount() {\n    this.updateTimeSerieEveryXSeconds(TIME_REPEAT);\n  } // keep the time serie clear and has only lmited amount of points \n\n\n  render() {\n    return /*#__PURE__*/React.createElement(\"div\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 83,\n        columnNumber: 7\n      }\n    }, /*#__PURE__*/React.createElement(\"h5\", {\n      className: \"no-margin\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 84,\n        columnNumber: 9\n      }\n    }, \"Number of customer in store every \", TIME_REPEAT, \" seconds\"), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"gray-background\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 85,\n        columnNumber: 9\n      }\n    }, /*#__PURE__*/React.createElement(\"canvas\", {\n      style: {\n        padding: '0 0 5px 0'\n      },\n      id: \"myChart\",\n      ref: this.chartRef,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 86,\n        columnNumber: 13\n      }\n    })));\n  }\n\n}\n\nexport default TimeSerie;","map":{"version":3,"sources":["/home/alexkimory/react-test/src/components/section/charts/TimeSerie.js"],"names":["React","Chart","generateCurrentTime","generateRandomNumber","TIME_REPEAT","TimeSerie","Component","chartRef","createRef","state","data","labels","limitSizeOfStateData","size","lengh","console","log","reducedSize","slice","setState","updateTimeSerieEveryXSeconds","second","setInterval","myChartRef","current","getContext","type","datasets","borderColor","showLine","fill","label","options","scales","yAxes","stacked","ticks","suggestedMin","suggestedMax","maxTicksLimit","beginAtZero","stepSize","xAxes","componentDidMount","render","padding"],"mappings":"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","sourcesContent":["import React from \"react\";\nimport { Chart } from \"chart.js\";\nimport generateCurrentTime from \"../../../utils/generateCurrentTime\";\nimport generateRandomNumber from \"../../../utils/generateRandomNumber\";\n\nconst TIME_REPEAT = 2;\nclass TimeSerie extends React.Component {\n  chartRef = React.createRef();\n  state = {\n    data: [],\n    labels: [],\n  };\n  componentDidMount() {\n    this.updateTimeSerieEveryXSeconds(TIME_REPEAT);\n  }\n  // keep the time serie clear and has only lmited amount of points \n  limitSizeOfStateData = (size) => {\n    if (this.state.data.lengh > size) {\n      console.log('in limted size data',this.state.data.lengh )\n      let reducedSize = this.state.data.lengh - size;\n      let data = this.state.data.slice(reducedSize);\n      console.log('after cut limted size data',data);\n      this.setState({data : data});\n    }\n\n    if (this.state.labels.lengh > size) {\n      let reducedSize = this.state.labels.lengh - size;\n      let labels = this.state.labels.slice(reducedSize);\n      this.setState({labels : labels});\n    }\n  }\n  updateTimeSerieEveryXSeconds = (second) => {\n    setInterval(() => {\n      console.log('this.s.data', this.state.data);\n      this.limitSizeOfStateData(3);\n      console.log('this.s.data', this.state.data);\n      //update y axis with abitrary number of customer\n      this.setState({ data: [...this.state.data, generateRandomNumber()] });\n\n      //update x axis with current time hour:minute:second\n      this.setState({ labels: [...this.state.labels, generateCurrentTime()] });\n\n      //create chart and update it every X seconds\n      const myChartRef = this.chartRef.current.getContext(\"2d\");\n\n      new Chart(myChartRef, {\n        type: \"line\",\n        data: {\n          labels: this.state.labels,\n          datasets: [\n            {\n              borderColor: \"red\",\n              showLine: true,\n              fill: false,\n              label: \"Customer in store\",\n              data: this.state.data,\n            },\n          ],\n        },\n        options: {\n          scales: {\n            yAxes: [\n              {\n                stacked: true,\n                ticks: {\n                  suggestedMin: 0,\n                  suggestedMax: 100,\n                  maxTicksLimit: 5,\n                  beginAtZero: true,\n                  stepSize: 0.5,\n                },\n              },\n            ],\n            xAxes: [],\n          },\n        },\n      });\n    }, second * 1000);\n  };\n\n  render() {\n    return (\n      <div>\n        <h5 className=\"no-margin\">Number of customer in store every {TIME_REPEAT} seconds</h5>\n        <div className=\"gray-background\">\n            <canvas style={{padding:'0 0 5px 0'}} id=\"myChart\" ref={this.chartRef} />\n        </div>\n        \n      </div>\n    );\n  }\n}\n\nexport default TimeSerie;\n"]},"metadata":{},"sourceType":"module"}